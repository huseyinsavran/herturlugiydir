
		"//saat yönünde karenin kenarý üzrinde gezer",
		"//en yakýn noktayý hesaplar, eðer bulursa",
		"vec4 NKomsulugundaAra( int n, sampler2D image, vec2 uv)",
		"{",
		"   float thresAlpha = 0.0;", 
		"	float enKucukMesafe = (float)INT_MAX;",
		"	vec2 uvGezen = ivec2(uv.x - n, uv.y + n); //sol ust koseye taþýdýk",
		"	int uzunluk = (2 * n) +1; //kenar uzunluðu",
		
		"	float mesafe;",
		"	vec4 tex = vec4(1.0);",
		"	vec4 out = vec4(1.0);",
			
		"	//soldan saða en üst yatay kenar aranýr",
		"	for( int i = 0; i < uzunluk; i++,uvGezen.x++)",
		"	{",
		"		if(uvGezen.x < 0 || uvGezen.y < 0 || uvGezen.x >= w || uvGezen.y >= h ) continue;",
		"		tex = texture2D( image, uvGezen );",
		"		if(tex[3] > thresAlpha) // bu saydam deðil demektir. rengi alýnabilir",
		"		{",
		"			 
		"			 mesafe = length(uvGezen - uv);",
					 
		"			 //güncelleme",
		"			 if(mesafe < enKucukMesafe)",
		"			 {",
		"				enKucukMesafe = mesafe;",
		"				out = tex;",
		"			 }",
		"		}",
		"	}",
			
		"	uvGezen.x = uv.x - n;",
		"	uvGezen.y = uv.y - n;",
		"	//soldan saða en alt yatay kenar aranýr",
		"	for( int i = 0; i < uzunluk; i++,uvGezen.x++)",
		"	{",
		"		if(uvGezen.x < 0 || uvGezen.y < 0 || uvGezen.x >= w || uvGezen.y >= h ) continue;",
		"		tex = texture2D( image, uvGezen );",
		"		if(tex[3] > thresAlpha) // bu saydam deðil demektir. rengi alýnabilir",
		"		{",
		"			  mesafe = length(uvGezen - uv);",
		"			 //güncelleme",
		"			 if(mesafe < enKucukMesafe)",
		"			 {",
		"				enKucukMesafe = mesafe;",
		"				out = tex;",
		"			 }",
		"		}",
		"	}",
			
		"	uzunluk -= 2; //köþeler önceki yatay geçiþler tarafýndan tüketildi",
		"	//yukardan aþaðý sol taraf	",
		"	uvGezen.x = uv.x - n;",
		"	uvGezen.y = uv.y + n-1; //bir alttan baþlar					",
		"	for( int i = 0; i < uzunluk; i++,uvGezen.y--)",
		"	{",
		"		if(uvGezen.x < 0 || uvGezen.y < 0 || uvGezen.x >= w || uvGezen.y >= h ) continue;",
		"		tex = texture2D( image, uvGezen );",
		"		if(tex[3] > thresAlpha) // bu saydam deðil demektir. rengi alýnabilir",
		"		{",
		"			  mesafe = length(uvGezen - uv);",
		"			 //güncelleme",
		"			 if(mesafe < enKucukMesafe)",
		"			 {",
		"				enKucukMesafe = mesafe;",
		"				out = tex;",
		"			 }",
		"		}",
		"	}",
		"	//yukardan aþaðý sag taraf	",
		"	uvGezen.x = uv.x + n;",
		"	uvGezen.y = uv.y + n-1; //bir alttan baþlar					",
		"	for( int i = 0; i < uzunluk; i++,uvGezen.y--)",
		"	{",
		"		if(uvGezen.x < 0 || uvGezen.y < 0 || uvGezen.x >= w || uvGezen.y >= h ) continue;",
		"		tex = texture2D( image, uvGezen );",
		"		if(tex[3] > thresAlpha) // bu saydam deðil demektir. rengi alýnabilir",
		"		{",
		"			  mesafe = length(uvGezen - uv);",
		"			 //güncelleme",
		"			 if(mesafe < enKucukMesafe)",
		"			 {",
		"				enKucukMesafe = mesafe;",
		"				out = tex;",
		"			 }",
		"		}",
		"	}",
		
		"	 return out;",
		"}",
		"//verilen uv posizyonuna en yakýn noktanýn posizyonu aranýr",
		"vec4 findTheClosestPixel(sampler2D image, vec2 uv, int w, int h,vec4 tex)",
		"{",
		"	bool basarili = false;",
		"	//En uzak köþeye olan en uzak kenar",
		"	int NLimit = max(w - uv.x, h - uv.y) + 1; ",
		"	vec4 outPut = vec4(1.0); ",
		"	for(int i = 1; i < NLimit; i++)",
		"	{",
		"		outPut = NKomsulugundaAra( i, image, uv);",
		"		if(outPut[3] > 0){basarili =true; break;}",
		"	}",
			
		"	if(basarili) return outPut;",
		"	else return tex; //aynen döndür",
			
		"}",
		
		"	//tex = findTheClosestPixel(tDiffuse, vUv, w, h,tex);",